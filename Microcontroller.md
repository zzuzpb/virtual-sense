# The Microcontroller Unit #

Virtualsense node is based upon Texas Instruments MSP430F54xxa ultra-low-power microcontrollers. The microcontroller unit (MCU) has an optimized architecture and exhibits a large set of low-power inactive modes conceived to achieve extended battery life in portable measurement applications and to enable the implementation of autonomous WSNs harvesting supply power from the environment. Nevertheless, the MCU is a powerful 16-bit RISC CPU running at up to 25MHz with a built-in digitally controlled oscillator (DCO) which allows wake-up from low-power to active modes in less than 5 μs.
Moreover the MCU is equipped with three 16-bit timers, a high performance 12-bit ADC, a hardware multiplier, a DMA controller, and four universal serial communication interfaces (USCI) which can be used as SPI/UART/I2C buses.


## Low power modes ##


The MCU has one active mode and 6 software selectable low-power modes called LPM0, LPM1, LPM2, LPM3, LPM4, and LPM4.5. Transitions from low power modes to active mode are triggered by internal or external interrupt events. Upon an interrupt event the MCU wakes up, handles the interrupt, and goes back to the original low-power mode. From LPM0 to LPM3 the MCU progressively shuts down the CPU and the internal clock modules while maintaining the internal DCO up and running in order to make it possible for the programmer to schedule self-events to reactivate the MCU (in less than 5µs) in order to perform periodic monitoring tasks while taking advantage of the inactive states to save power in between.
On the contrary, the internal DCO and the crystal oscillator are turned off in LPM4 and LPM4.5, thus avoiding the generation of self-events. In order to wake up the MCU from these deep low-power states, an external interrupt needs to be raised on digital I/O ports P1 and P2. In our architecture, external timer interrupts can be generated by the RTC.
In low power modes LPM0-LPM4 the MCU retains both the content of main memory and the configuration/state of its I/O ports, so that wakeup events can be processed by the corresponding interrupt service routines without any reset.

On the other hand, in the lowest inactive mode (namely, LPM4.5) the voltage regulator of the MCU power management module (PMM) is completely disabled, so that no power supply is provided to the  CPU, to main memory, and to all digital modules. As a consequence, the device is completely disabled and all the volatile data and configurations are lost. The only piece of information which is retained is the condition of the pins.

| **Low power mode** | **Current consumption** | **Unit** |
|:-------------------|:------------------------|:---------|
|Active (@ 25Mhz) | 8.9 | mA |
| LPM0	| 73 | µA |
| LPM1	| 11.7 | µA |
| LPM2	| 2.3 | µA |
| LPM3 | 1.4 | µA |
| LPM4 | 1.3 | µA |
| LPM4.5 | 0.1 | µA |

**Table 1. MCU power modes current consumption**

Exit from LPM4.5 causes a complete reset of the system, entailing the reboot of the MCU and of all firmware components.  Wakeup time from LPM4.5 is significantly longer than from other inactive modes for two main reasons: first, the supply voltage of the core needs to be regenerated, second, the entire software stack has to be restarted before resuming operation. Moreover, data persistency has to be explicitly handled by the application developer exploiting external non-volatile memory devices.
It is worth noticing that, whenever the MCU enters in LPM4.5, the LOCKIO bit of register PM5CTL0 belonging to the PMM module is automatically set causing all I/O pins to be locked in their current status (please refer to Section “Low-Power Design Tips” for the details). This makes it necessary, at wakeup, to unlock the PMM module and clear the PM5CTL0 register in order to properly reconfigure the I/O pins.

Figure 3 shows the code fragment needed to enable I/O pin configuration, while Table 1 shows typical power consumption of the MCU in its different power states.

```
/* remove PM5 lock to enable I/O pin
 * configuration needed when wake-up 
 * from LPM4.5
 */
 PMMCTL0_H = PMMPW_H; // open PMM with password
 PM5CTL0 &= ~LOCKIO;  // Clear LOCKIO 
 PMMCTL0_H = 0x00;    // close PMM

```
**Figure 3: Enable I/O pins configuration after exiting from LPM4.5**


## Power Management Module (PMM) and Supply Voltage Supervisor (SVS) ##


The PMM has the main function to generate the supply voltage for the core (VCORE) starting from the voltage applied to the device (DVCC), while the SVS provides several mechanisms for the supervision and monitoring of the values of both DVCC and VCORE.
In general, VCORE supplies the CPU, the memories (flash/RAM), and the digital modules, while DVCC supplies I/Os and all analog modules (including oscillators). The PMM can provide four different levels of VCORE and it can be programmed in order to select the lowest supply voltage compatible with the speed of the CPU. In fact, the minimum voltage needed by the core depends on the selected CPU frequency.
The PMM and the SVS make available four software-programmable voltage thresholds to supervise and monitor the levels of DVCC and VCORE. In particular DVCC is supervised and monitored by the high-side supervisor (SVSH) and high-side monitor (SVMH), respectively while VCORE is supervised and monitored by the low-side supervisor (SVSL) and low-side monitor (SVML), respectively. Whenever a monitoring threshold is crossed, the PMM generates an interrupt that can be handled by a specific software routine. On the contrary, whenever a supervisor threshold is crossed, the SVS automatically resets the MCU by means of a power-on reset (POR) event.

## Digital I/O Module ##


The MCU has up to twelve 8-bit digital I/O ports (the real number depends on the pinout of the chip) called P1 to P11 plus a unnumbered port called PJ, which can be used to implement the JTAG communication protocol in order to easily reprogram the MCU. Each port (but PJ) provides eight I/O lines which can be independently configured in input or output (by means of PxDIR registers) and independently read or written. Moreover, it is possible to enable or disable a pullup or pulldown resistor in each port using the PxREN register. Finally, each port, while configured in output direction (PxDIR=1), can be programmed in full or reduced drive strength by means of PxDS registers. In reduced drive strength mode each I/O line can drive up to 15mA while in full drive strength the maximum drive current reaches 50mA.
Only ports P1 and P2 provide interrupt capabilities and can wake up the MCU from any low power mode. The 16 lines of the two ports can be individually enabled and configured to be sensitive to rising or falling edges of the corresponding input signals. Each I/O port is characterized by a low leakage current in  the 50nA range.
Port pins are often multiplexed with other peripheral module functions, such as SPI, I2C, UART, which can be activated by means of the corresponding PxSEL bits. It is worth mentioning that the binding between port pins and interface bits is hardwired.


## Universal Serial Communication Interface (USCI) ##


The MSP430f54xxa MCU is equipped with four different USCI modules, supporting multiple serial communication modes. In particular, the MCU has two USCI\_A modules (USCI\_A0 and USCI\_A1) and two USCI\_B modules (USCI\_B0 and USCI\_B1). While USCI\_Ax modules support UART mode, pulse shaping for IrDA communications, and SPI mode, USCI\_Bx modules support only I2C and SPI modes.
In order to use an I/O line in USCI mode the corresponding PxSEL bit needs to be set to disconnect the pin from the general purpose I/O module and to establish the connection with the corresponding bit of the USCI module.


## 12 bit ADC Module ##

The ADC module supports fast 12-bit analog-to-digital conversions. This module implements a 12-bit sample select control, a reference generator, and a 16-word  conversion-and-control buffer. Thanks to the built-in buffer, the ADC can sample and convert up to 16 independent signals without involving the CPU. Depending on the conversion mode, subsequent samples taken from each channel are overwritten in the buffer. So that the CPU can decide when to access the buffer to read the last sampled values.
The ADC module allows the programmer to select: the sampling period, the on-chip reference voltage, and the internal conversion clock source.
Moreover, it provides four different conversion modes: i) single-channel, ii) repeat-single-channel, which overwrite the samples, iii) autoscan, which takes and convert a sample from all enabled channels, iv) and repeated autoscan, which repeatedly scans all the enabled channels.

## Low-Power Design Tips ##
Achieving the nominal low-power levels specified in the datasheet of the MCU is not a trivial task, since the actual consumption of each low-power mode strongly depends on the configuration of the MSP430f54xxa MCU.
This section outlines a few tricks which can help the developer to approach the lower bound.
First of all, the programmer has to take care of the status of the I/O pins in order to avoid uncontrolled current leakage. To this purpose, we need to distinguish connected/used pins and  unconnected/unused I/O pins. Each unconnected pin has to be configured as general purpose I/O with output direction during code initialization and left unconnected (rather than grounded) on the PCB. Connected pins, on the contrary, have to be properly configured when not used (i.e. when the MCU enters in a low-power state or when the connected peripheral is shut down or not used). For this reason, for example, before entering in LPM4.5 all the pins have to be set to general purpose I/O and configured in “input high impedance”. In fact, it is critical that no inputs are left floating or otherwise an uncontrolled extra current can be drawn by the MCU. In the same way digital I/O pins controlling an external peripheral should be configured (if possible) to “input high impedance” in order to prevent significant current drain between the MCU and the peripheral, when it is not used.
Finally, each internal MCU module, such as ADC converter, USCI interfaces, DMA controller, SVS, PMM, and internal RTCs should be shut down when unused in order to minimize power consumption.

